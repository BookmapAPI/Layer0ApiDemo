package velox.api.layer0.live;

import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicInteger;

import velox.api.layer0.annotations.Layer0LiveModule;
import velox.api.layer1.data.ExecutionInfo;
import velox.api.layer1.data.Layer1ApiProviderSupportedFeatures;
import velox.api.layer1.data.OrderCancelParameters;
import velox.api.layer1.data.OrderDuration;
import velox.api.layer1.data.OrderInfoBuilder;
import velox.api.layer1.data.OrderMoveParameters;
import velox.api.layer1.data.OrderResizeParameters;
import velox.api.layer1.data.OrderSendParameters;
import velox.api.layer1.data.OrderStatus;
import velox.api.layer1.data.OrderType;
import velox.api.layer1.data.OrderUpdateParameters;
import velox.api.layer1.data.SimpleOrderSendParameters;
import velox.api.layer1.data.SystemTextMessageType;

/**
 * <p>
 * This provider generates data according to same rules as parent provider, but
 * also has some trading capabilities.
 * </p>
 *
 * <p>
 * It does not aim to be realistic, so it's somewhat simplified.
 * </p>
 */
@Layer0LiveModule(fullName = "Demo external trading", shortName = "DT")
public class DemoExternalRealtimeTradingProvider extends DemoExternalRealtimeProvider {

    AtomicInteger orderIdGenerator = new AtomicInteger();
    AtomicInteger executionIdGenerator = new AtomicInteger();

    private HashMap<String, OrderInfoBuilder> workingOrders = new HashMap<>();

    @Override
    public void sendOrder(OrderSendParameters orderSendParameters) {
        // Since we did not report OCO/OSO/Brackets support, this method can
        // only receive simple orders
        SimpleOrderSendParameters simpleParameters = (SimpleOrderSendParameters) orderSendParameters;

        // Detecting order type
        OrderType orderType = OrderType.getTypeFromPrices(simpleParameters.stopPrice, simpleParameters.limitPrice);

        // Even if order will be rejected provider should first acknowledge it
        // with PENDING_SUBMIT.
        // This allows Bookmap visualization to distinguish between orders that
        // were just sent and orders that were rejected earlier and now the last
        // state is reported
        // If your datasource does not provide some variation of PENDING_SUBMIT
        // status, you are advised to send a fake message with PENDING_SUBMIT
        // before reporting REJECT - this will make Bookmap consider all rejects
        // to be new ones instead of historical ones
        final OrderInfoBuilder builder = new OrderInfoBuilder(
                simpleParameters.alias,
                // ID should normally be generated by exchange
                "o" + orderIdGenerator.incrementAndGet(),
                simpleParameters.isBuy,
                orderType,
                simpleParameters.clientId,
                simpleParameters.doNotIncrease);
        // You need to set these fields, otherwise Bookmap might not handle
        // order correctly
        builder.setStopPrice(simpleParameters.stopPrice)
                .setLimitPrice(simpleParameters.limitPrice)
                .setUnfilled(simpleParameters.size)
                .setDuration(OrderDuration.GTC)
                .setStatus(OrderStatus.PENDING_SUBMIT);
        tradingListeners.forEach(l -> l.onOrderUpdated(builder.build()));
        // Marking all fields as unchanged, since they were just reported and
        // fields will be marked as changed automatically when modified.
        builder.markAllUnchanged();

        // First, since we are not going to emulate stop or market orders in
        // this demo,
        // let's reject anything except for Limit orders.
        if (orderType != OrderType.LMT) {
            // Necessary fields are already populated, so just change status to
            // rejected and send
            builder.setStatus(OrderStatus.REJECTED);
            tradingListeners.forEach(l -> l.onOrderUpdated(builder.build()));
            builder.markAllUnchanged();

            // Provider can complain to user here explaining what was done wrong
            adminListeners.forEach(l -> l.onSystemTextMessage("This provider only supports limit orders",
                    SystemTextMessageType.ORDER_FAILURE));
        } else {
            // We are going to simulate this order, entering WORKING state
            builder.setStatus(OrderStatus.WORKING);
            tradingListeners.forEach(l -> l.onOrderUpdated(builder.build()));
            builder.markAllUnchanged();

            // Placing it into list of working orders so it will be simulated.
            // Synchronizing since trading simulation will be done in different
            // thread
            synchronized (workingOrders) {
                workingOrders.put(builder.getOrderId(), builder);
            }
        }

    }

    @Override
    public void updateOrder(OrderUpdateParameters orderUpdateParameters) {

        // OrderMoveToMarketParameters will not be sent as we did not declare
        // support for it, 3 other requests remain

        synchronized (workingOrders) {
            // instanceof is not recommended here because subclass, if it appears,
            // will anyway mean an action that existing code can not process as
            // expected
            if (orderUpdateParameters.getClass() == OrderCancelParameters.class) {

                // Cancel order with provided ID
                OrderCancelParameters orderCancelParameters = (OrderCancelParameters) orderUpdateParameters;
                OrderInfoBuilder order = workingOrders.remove(orderCancelParameters.orderId);
                order.setStatus(OrderStatus.CANCELLED);
                tradingListeners.forEach(l -> l.onOrderUpdated(order.build()));

            } else if (orderUpdateParameters.getClass() == OrderResizeParameters.class) {

                // Resize order with provided ID
                OrderResizeParameters orderResizeParameters = (OrderResizeParameters) orderUpdateParameters;
                OrderInfoBuilder order = workingOrders.get(orderResizeParameters.orderId);
                order.setUnfilled(orderResizeParameters.size);
                tradingListeners.forEach(l -> l.onOrderUpdated(order.build()));

            } else if (orderUpdateParameters.getClass() == OrderMoveParameters.class) {

                // Change stop/limit prices of an order with provided ID
                OrderMoveParameters orderMoveParameters = (OrderMoveParameters) orderUpdateParameters;
                OrderInfoBuilder order = workingOrders.get(orderMoveParameters.orderId);
                // No need to update stop price as this demo only supports limit
                // orders
                order.setLimitPrice(orderMoveParameters.limitPrice);
                tradingListeners.forEach(l -> l.onOrderUpdated(order.build()));
                
                // New price might trigger execution
                simulateOrders();

            } else {
                throw new UnsupportedOperationException("Unsupported order type");
            }
        }
    }


    @Override
    public Layer1ApiProviderSupportedFeatures getSupportedFeatures() {
        // Expanding parent supported features, reporting basic trading support
        return super.getSupportedFeatures()
                .toBuilder()
                .setTrading(true)
                .setSupportedOrderDurations(Arrays.asList(new OrderDuration[] { OrderDuration.GTC }))
                // At the moment of writing this method it was not possible to
                // report limit orders support, but no stop orders support
                // If you actually need it, you can report stop orders support
                // but reject stop orders when those are sent.
                .setSupportedStopOrders(Arrays.asList(new OrderType[] { OrderType.LMT, OrderType.STP }))
                .build();
    }

    @Override
    protected void simulate() {
        // Perform data changes simulation
        super.simulate();

        simulateOrders();
    }

    public void simulateOrders() {
        // Simulate order executions
        synchronized (workingOrders) {
            synchronized (instruments) {
                // Purging orders that are no longer working - those do not have
                // to be simulated
                workingOrders.values().removeIf(o -> o.getStatus() != OrderStatus.WORKING);

                for (OrderInfoBuilder order : workingOrders.values()) {
                    Instrument instrument = instruments.get(order.getInstrumentAlias());

                    // Only simulating if user is subscribed to instrument -
                    // this is because we do not generate data when there is no
                    // subscription
                    if (instrument != null) {
                        // Determining on which price level order can be
                        // executed. Note the multiplication by pips part -
                        // that's because order price is a raw value and
                        // instrument bid/ask are level numbers.

                        double bestPrice = order.isBuy()
                                ? instrument.getBestAsk() * instrument.pips
                                : instrument.getBestBid() * instrument.pips;

                        boolean shouldBeExecuted = order.isBuy()
                                ? bestPrice <= order.getLimitPrice()
                                : bestPrice >= order.getLimitPrice();

                        if (shouldBeExecuted) {
                            // For simplicity fully executing order with the
                            // best price

                            // Reporting executions.
                            int unfilled = order.getUnfilled();
                            // Generating id for execution - usually will be
                            // received from exchange
                            final String executionId = "e" + executionIdGenerator.incrementAndGet();
                            final long executionTime = System.currentTimeMillis();
                            // Note that last parameter is execution time. While
                            // time of event itself can be derived from the time
                            // when it was sent for realtime executions, you are
                            // allowed to send historical executions for those
                            // to be displayed in account info panel.
                            ExecutionInfo executionInfo = new ExecutionInfo(order.getOrderId(), unfilled, bestPrice,
                                    executionId, executionTime);
                            tradingListeners.forEach(l -> l.onOrderExecuted(executionInfo));

                            // Changing the order itself
                            order.setAverageFillPrice(bestPrice);
                            order.setUnfilled(0);
                            order.setFilled(unfilled);
                            order.setStatus(OrderStatus.FILLED);
                            tradingListeners.forEach(l -> l.onOrderUpdated(order.build()));
                            order.markAllUnchanged();
                        }
                    }
                }
            }
        }
    }
}
